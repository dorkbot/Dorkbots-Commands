package dorkbots.dorkbots_ui {	import flash.text.TextField;

	public class TruncateTextField 	{		public function TruncateTextField(pvt:PrivateClass)		{					}				public static function truncateText( textField:TextField, addEllipsis:Boolean = true, minimizeLines:uint = 0, ellipsis:String = "\u2026" ):uint		{			var truncateText:TruncateTextField = new TruncateTextField(new PrivateClass());			return truncateText.truncateText(textField, addEllipsis, minimizeLines, ellipsis);		}						/**		 * Truncate html text.		 * @param value The original text value		 * @param limit The maximum number of characters to show		 * @param addEllipsis  Boolean value to show elipses at the end of truncation.		 * @param addMoreLink  Boolean value to show a "[more]" with a TextEvent (TextEvent.LINK) at the end of truncation.		 * This method is based on Michael Ritchie's work at http://thanksmister.com/2009/07/12/flex-truncating-html-text/		 * */		public static function truncateHTMLText(value:String, limit:int, addEllipsis:Boolean = true, addMoreLink:Boolean = true):String		{				var truncateText:TruncateTextField = new TruncateTextField(new PrivateClass);			return truncateText.truncateHTMLText(value, limit, addEllipsis, addMoreLink);		}						// CORE LOGIC		public function truncateText( textField:TextField, addEllipsis:Boolean = true, minimizeLines:uint = 0, ellipsis:String = "\u2026" ):uint		{			var tempTextField:TextField;						var characterRemoveCnt:uint = 0;						if ( ! textOverflowing( textField ) ) return characterRemoveCnt;						// copy the text field and then extracting its text is appears to be causing inconstancies with the number of lines in the original text field. 			// trying to work directly with the original text field			//tempTextField = copyTextField( textField );			tempTextField = textField;						while( textOverflowing( tempTextField, minimizeLines, ellipsis ) )			{				characterRemoveCnt++;				tempTextField.text = tempTextField.text.substr( 0, tempTextField.text.length - 1 );			}						// Remove any empty spaces and periods at the end			var continueEndTidying:Boolean = true;			while(continueEndTidying)			{				continueEndTidying = false;								if (tempTextField.text.charAt(tempTextField.text.length - 1) == " ") continueEndTidying = true;				// remove any periods if we are adding ellipsis				if (addEllipsis && tempTextField.text.charAt(tempTextField.text.length - 1) == ".") continueEndTidying = true;								if (continueEndTidying)				{					characterRemoveCnt++;					tempTextField.text = tempTextField.text.slice(0, -1);				}								// just in case, because while loops make me nervous				if (tempTextField.text.length <= 0) break;			}						// add ellipsis			if (addEllipsis)			{				//trace("1 [TruncateTextField] truncateText -> tempTextField.numLines = " + tempTextField.numLines);				var oldNumLines:uint = tempTextField.numLines;				// add ellipsis				tempTextField.appendText( ellipsis );				//trace("2 [TruncateTextField] truncateText -> tempTextField.numLines = " + tempTextField.numLines);				// check again, for some reason, adding the ellipsis can increase number of lines				while(tempTextField.numLines > oldNumLines)				{					// remove ellipsis and last character					characterRemoveCnt++;					tempTextField.text = tempTextField.text.substr( 0, tempTextField.text.length - ellipsis.length - 1 );					// remove any spaces					if (tempTextField.text.charAt(tempTextField.text.length - 1) == " ")					{						characterRemoveCnt++;						tempTextField.text = tempTextField.text.slice(0, -1);					}					// add ellipsis back					tempTextField.appendText( ellipsis );					// just in case, because while loops make me nervous					if (tempTextField.text.length <= 0) break;				}				//trace("3 [TruncateTextField] truncateText -> tempTextField.numLines = " + tempTextField.numLines);				/*if (tempTextField.numLines > 1) 				{					// check again, for some reason, adding the ellipsis can increase number of lines					while( textOverflowing( tempTextField, minimizeLines, ellipsis ) )					{						characterRemoveCnt++;						tempTextField.text = tempTextField.text.substr( 0, tempTextField.text.length - ellipsis.length - 1 );					}										trace("appendText");					tempTextField.appendText( ellipsis );				}*/			}			/*trace("4 [TruncateTextField] truncateText -> tempTextField.numLines = " + tempTextField.numLines);			trace("[TruncateTextField] truncateText -> tempTextField.width = " + tempTextField.width);			trace("[TruncateTextField] truncateText -> tempTextField.height = " + tempTextField.height);*/			//textField.text = "";			/*trace("1 [TruncateTextField] truncateText -> textField.numLines = " + textField.numLines);*/			//textField.text = tempTextField.text;			/*trace("2 [TruncateTextField] truncateText -> textField.numLines = " + textField.numLines);			trace("[TruncateTextField] truncateText -> textField.width = " + textField.width);			trace("[TruncateTextField] truncateText -> textField.height = " + textField.height);*/			return characterRemoveCnt;		}				private function textOverflowing( textField:TextField, minimizeLines:uint = 0, suffix:String = null ):Boolean		{			var margin:Number = 2; //Flash adds this to all textfields						var tempTextField:TextField = copyTextField( textField );						if ( suffix ) tempTextField.appendText( suffix );			if (minimizeLines > 0 && tempTextField.numLines > minimizeLines) return true;						if ( tempTextField.textWidth > tempTextField.width - margin || tempTextField.textHeight > tempTextField.height - margin ) return true;						return false;		}				private function copyTextField( original:TextField ):TextField		{			var copy:TextField = new TextField();						copy.x = original.x;			copy.y = original.y;			copy.width = original.width;			copy.height = original.height;			copy.multiline = original.multiline;			copy.wordWrap = original.wordWrap;			copy.embedFonts = original.embedFonts;			copy.antiAliasType = original.antiAliasType;			copy.autoSize = original.autoSize;			copy.defaultTextFormat = original.getTextFormat();			copy.text = original.text;						return copy;		}				/**		 * Truncate html text.		 * @param value The original text value		 * @param limit The maximum number of characters to show		 * @param addEllipsis  Boolean value to show elipses at the end of truncation.		 * @param addMoreLink  Boolean value to show a "[more]" with a TextEvent (TextEvent.LINK) at the end of truncation.		 * This method is based on Michael Ritchie's work at http://thanksmister.com/2009/07/12/flex-truncating-html-text/		 * */		public function truncateHTMLText(value:String, limit:int, addEllipsis:Boolean = true, addMoreLink:Boolean = true):String		{				if (!addEllipsis) limit += 3;			if (!addMoreLink) limit += 6;						if(limit <= 0) return "";						var original:String = value;						value = value.replace("[\\t\\n\\x0B\\f\\r\\u00A0]+", "");						var isTag:Boolean = false;			var count:int = 0;			var position:int = 0;			var limitLength:int = value.length - 1;			var closeTag:Boolean = false;						for(var i:int = 0; i < value.length; i++) 			{				var c:String = value.charAt(i);				if(isTag) 				{					if(c == '>') 					{						isTag = false;						if(closeTag || i == limitLength) 						{							position = i;							break;						}						continue;					} 					else 					{						continue;					}				} 				else 				{					if(c == '<') 					{						isTag = true;					} 					else 					{						count++;						if(i == limitLength || (count == limit)) 						{							if(((i+1) < limitLength) && ((i+2) < limitLength)) 							{								if(value.charAt(i+1) == '<' && value.charAt(i+2) == '/') 								{									closeTag = true;									continue;								}							}							position = i;							break;						}					}				}			}						var result:String = value.substring(0, position + 1);			var last:String = result.charAt(result.length - 1);			var length:int = result.length;						var nextChar:String = (length >= value.length) ? ' ' : value.charAt(length);						if(last != ' ' && last != '>' && nextChar != ' ' && nextChar != '<')			{				result = result.substring(0, result.lastIndexOf(' ') + 1);			}			var lastStartTag:int = result.lastIndexOf('<');						if(lastStartTag != -1)			{				var ch:String = result.charAt(lastStartTag + 1);				if(ch != '/') 				{					result = result.substring(0, lastStartTag);				}			}						if(original.length == result.length) return original;						if(result.length == 0) return result;						// Remove any empty spaces and periods at the end			while(result.charAt(result.length - 1) == " " || result.charAt(result.length - 1) == ".")			{				result = result.slice(0, -1);				// just incase, because while loops make me nervous				if (result.length <= 0) break;			}						// Remove any empty spaces and periods at the end			var continueEndTidying:Boolean = true;			while(continueEndTidying)			{				continueEndTidying = false;								if (result.charAt(result.length - 1) == " ") continueEndTidying = true;				// remove any periods if we are adding ellipsis				if (addEllipsis && result.charAt(result.length - 1) == ".") continueEndTidying = true;								if (continueEndTidying)				{					result = result.slice(0, -1);				}								// just in case, because while loops make me nervous				if (result.length <= 0) break;			}						var pattern:RegExp = new RegExp("(.*?)(\\s*\.\.\.\\s*)([\</[a-z]*?\>\\s*$]+)", "i");						if(result.search(pattern) == -1 && addEllipsis) result += "...";						if (addMoreLink)			{				return (result +  " <a href=\"event:more\">[more]</a>");			}			else			{				return result;			}		}	}}// this Private Class is only used to "jam" the param in the singleton constructor.  So only this singleton can instiate itselfclass PrivateClass{	public function PrivateClass()	{	}}